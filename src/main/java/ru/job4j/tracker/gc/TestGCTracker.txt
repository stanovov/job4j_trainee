Для эксперимента и нагрузки на GC был использован новый алгоритм. Представлен в классе TestGCTracker.
При старте программы были использованы ключи VM: -Xmx128m -Xms128m. При таких исходных данных программа выходит за
пределы допустимой памяти на 86 итерации внешнего цикла. Остановка в 30 секунд сделана, чтобы успеть начать мониторинг.
В ходе эксперемента были использованы следующие утилиты для профилирования: jmap, jstat и jconsole.
С помощью jmap можно оценить количество созданных объектов с разбивкой по классам на момент использования команды.
Намного интереснее наблюдать за результатом с помощью утилит jstat и jconsole.
jstat в реальном времени отображает статистику уборщика по колонкам:

S0C — Объем региона Survivor 0 в КБ
S1C — Объем региона Survivor 1 в КБ
S0U — Survivor 0 регион занял место в КБ
S1U — регион Survivor 1 занял место в КБ
EC — емкость региона Eden в КБ
ЕС — используемое пространство региона Эдема в КБ
OC — Емкость старого региона в КБ
OU — Используемое пространство старого региона в КБ
MC — емкость метапространства в КБ
MU — Используемое пространство метапространства в КБ
CCSC — объем областей сжатого пространства в КБ
CCSU — области пространства сжатого класса, занимающие место в КБ
YGC — Количество событий Young GC, которые произошли на данный момент
YGCT — количество времени, проведённого молодёжью в GC
FGC — количество событий Full GC , которые произошли на данный момент
FGCT — количество времени полного GC, потраченного до настоящего времени

jconsole же отображает в графическом удобном интерфейсе, какие ресурсы системы задействованы, сколько потоков GC
работают. Тоже в реальном времени.

Когда происходит переполнение памяти, из jconsole происходит "дисконнект". А jstat перестает "транслировать" статистику
по уборщику в консоль.